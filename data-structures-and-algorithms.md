# 计算复杂性
**概念**：用于分析算法在执行过程中所需资源的增长情况，主要包括 *时间复杂度* 和 *空间复杂度* 两个方面

## 时间复杂度
**概念**：时间复杂度是一个函数，它定性描述算法的运行时间。它用大O符号表示，不包括这个函数的低阶项和首项系数<br>
**常见时间复杂度（从快到慢）**：
- O(1)：常数级，如数组访问
- O(log n)：对数级，如二分查找
- O(n)：线性级，如遍历数组
- O(n log n)：线性对数级，如快速排序
- O(n²)：平方级，如嵌套循环
- O(2ⁿ)：指数级，如递归暴力搜索
- O(n!)：阶乘级，如全排列问题

# 数据结构
## 链表 Linked List
**概念**：一种动态数据结构，通过节点（Node）连接形成一条线性序列，每个节点包含 *数据部分* 和 *指针部分*<br>
**特点**：
- 内存不连续，靠指针连接
- 插入/删除效率高，不需要移动元素
    - 插入：

        <img src="https://i-blog.csdnimg.cn/direct/d04d286f97fe4d8ab92492518b537613.png#pic_center" width="350">
    - 删除：

        <img src="https://i-blog.csdnimg.cn/direct/eb93d8e04b1342b0883453ac11fabee6.png#pic_center" width="600">

- 顺序访问，也就是只能从第 1 个数据开始，顺着指针的指向一一往下访问

**类型**：
1. 单向链表：每个节点只指向下一个节点
`[head] -> [node1] -> [node2] -> ... -> null`

    <img src="https://i-blog.csdnimg.cn/direct/abf947d25b4349a08653d2c586f890af.png#pic_center" width="350">

2. 双向链表：每个节点有两个指针，分别指向前一个和后一个节点
`null <- [node1] <-> [node2] <-> [node3] -> null`
3. 循环链表：尾节点指向头节点形成一个闭环

## 数组 Array
**概念**：一种线性数据结构，用于按顺序存储元素，并支持通过索引快速访问<br>
**特点**：
- 元素在内存中连续存储
- 支持随机访问，通过下标直接访问元素，时间复杂度为 O(1)
- 插入/删除元素时需要移动元素，效率低（尤其是在中间位置）
    - 插入：

        <img src="https://i-blog.csdnimg.cn/direct/03d10ca7afe04e419b3b8db179d05bab.png#pic_center" width="600">

## 栈 Stack
**概念**：一种 *先进后出（LIFO, Last In First Out）* 的线性数据结构，只允许在一端进行插入和删除操作<br>
**特点**：
- 插入和删除操作只能在“栈顶”进行
    - 插入：

        <img src="https://i-blog.csdnimg.cn/direct/273576a8cdeb4936a04acd0adabaa834.png#pic_center" width="300">
    - 删除：

        <img src="https://i-blog.csdnimg.cn/direct/f0fe8e7e97b44176a41ba5db2f5b3a57.png#pic_center" width="300">

- 常用操作：`push`（入栈）、`pop`（出栈）、`top`（查看栈顶）、`isEmpty`（判空）

## 队列 Queue
**概念**：一种 *先进先出（FIFO，First In First Out）* 的线性数据结构，元素从队尾入队，从队头出队<br>
**特点**：
- 只能从一端插入（入队），另一端删除（出队）
    - 插入：

        <img src="https://i-blog.csdnimg.cn/direct/21cfa6a05263462493a90a07deb0c445.png#pic_center" width="300">
    - 删除：

        <img src="https://i-blog.csdnimg.cn/direct/88b0ab06b3a34fbea8077fc14ab024aa.png#pic_center" width="300">

- 操作受限，适合排队、调度等场景
- 常见操作：`enqueue`（入队）、`dequeue`（出队）、`peek`（查看队头）、`isEmpty`（判空）

## 哈希表 Hash Table
**概念**：一种基于 *键值对（key-value）* 的数据结构<br>
**特点**：
- 通过 *哈希函数* 将键映射到数组下标
- 查找、插入、删除操作的平均时间复杂度为 O(1)
- 适合用于频繁查找或统计数据出现次数的场景
- 键必须是可哈希（hashable）的
### 1）哈希函数（Hash Function）

- 将 key 映射为数组索引，例如：
  `index = hash(key) % array_size`

    <img src="https://i-blog.csdnimg.cn/direct/01665ba467ed491b909b121839c24b5c.png#pic_center" width="300">

### 2）冲突解决（Hash Collision）

<img src="https://i-blog.csdnimg.cn/direct/82db79c6c2194947b06d562fd28a3871.png#pic_center" width="600">

- **拉链法（链地址法）**：每个数组元素是一个链表，发生冲突时将多个元素放入链表中

    <img src="https://i-blog.csdnimg.cn/direct/c2ab4049d25c44bd9d3f1e31c192dbd4.png#pic_center" width="300">

- **开放地址法**：冲突时继续寻找下一个空位置（线性探测、二次探测、双哈希等）

*注意：如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此，给数组设定合适的空间非常重要

## 树
**术语**：
| 名称       | 描述                             |
|------------|----------------------------------|
| 根节点     | 最顶层节点                        |
| 叶子节点   | 没有子节点的节点，度为0       |
| 高度/深度  | 从根到当前节点/节点到叶子节点的距离 |
| 节点的度   | 一个节点含有子树的个数 |
| 树的度     | 一棵树中，最大的节点的度 |
| 结点的层次 | 规定根结点在1层，其它任一结点的层数是其父结点的层数加1 |

<img src="https://i-blog.csdnimg.cn/direct/ad97dc021d04479785c1e30a897b8105.png#pic_center" width="400">

如上图中：<br>
结点A和D的度数为3，结点E、F、G、H、I、J的度数均为0;<br>
树的度为 3;<br>
A结点的层次是 1, B、C、D结点的层次是2;<br>
树的深度是3

### 二叉树
**定义**：每个节点最多有两个子节点<br>
**分类**：
1. 满二叉树 (完美二叉树)：除了叶子结点，每个结点的度都为2
2. 完全二叉树：只缺最后一层的部分节点，且从左到右填满
3. 平衡二叉树：任意节点左右子树高度差 ≤ 1（如 AVL 树）
4. 搜索二叉树（BST）：左小右大，且递归满足二叉搜索树性质

#### 堆 Heap
**概念**：堆是一种特殊的 *完全二叉树* ，常用于实现 *优先队列（Priority Queue）* <br>
**特点**：
- 完全二叉树：除了最后一层，其他层节点个数都是满的，最后一层的节点都集中在左侧连续位置
- 堆中每一个节点的值都必须大于等于（或小于等于）其子节点的值
    - **大顶堆（最大堆）**：每个节点的值 ≥ 其子节点的值
    - **小顶堆（最小堆）**：每个节点的值 ≤ 其子节点的值
        - 添加数据：在堆的最后添加数据后，数据会一边比较它与父结点数据的大小，一边往上移动，直到满足堆的条件为止。添加数据需要的运行时间与树的高度成正比，假设数据量为n，根据堆的形状特点可知树的高度为log2n，时间复杂度是 O(logn)

            <img src="https://i-blog.csdnimg.cn/direct/6e2d6261e408494d8a6991572e901f28.png#pic_center" width="500">

        - 取出数据：需要将最后的数据移到最顶端，然后一边比较它与子结点数据的大小，一边往下移动，所以取出数据需要的运行时间和树的高度成正比，那么重构树的时间复杂度便为 O(logn)
- 堆是完全二叉树，因此大部分时候使用数组来存储堆

##### 堆化
**概念**：对数组元素顺序进行调整，以满足堆的特性，这个调整过程叫做堆化<br>
**分类**：
1. 从下往上（上浮）：当前元素不断向上和父节点比较大小
2. 从上往下（下沉）：当前元素不断向下和两个孩子节点比较大小

#### 二叉查找树 BST，Binary Search Tree
**特点**：
- 每个结点的值均 *大于* 其左子树上任意一个结点的值
- 每个结点的值均 *小于* 其右子树上任意一个结点的值

**总结**：二叉查找树的最小结点要从顶端开始，往其左下的末端寻找。反过来，二叉查找树的最大结点要从顶端开始，往其右下的末端寻找

# 排序
| 排序算法 | 时间复杂度 | 
| ---- | ---------- |
| 冒泡排序 | O(n²)      | 
| 选择排序 | O(n²)      |
| 插入排序 | O(n²)      | 
| 堆排序   | O(n log n) |
| 归并排序 | O(n log n) | 
| 快速排序 | O(n log n) | 

## 冒泡排序 Bubble Sort
**概念**：一种比较相邻元素并多轮交换的排序算法<br>
**步骤**：
1. 每轮从左到右，相邻元素两两比较，把较大的元素“冒”到右侧。
2. 共需进行 n-1 轮，每轮将未排序部分的最大值移动到末尾

## 选择排序 Selection Sort
**概念**：一种重复从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换的排序算法<br>
**步骤**：
1. 每轮从未排序区间中选择最小值，放到已排序区间末尾
2. 共进行 n - 1 轮，每轮确定一个当前最小值的位置

## 插入排序 Insertion Sort
**概念**：一种从序列左端开始依次对数据进行排序的算法。插入排序的思路就是从右侧的未排序区域内取出一个数据，然后将它插入到已排序区域内合适的位置上<br>
**步骤**：
1. 将数组划分为已排序区间和未排序区间
2. 每轮从未排序区间取出一个元素，插入到已排序区间的合适位置

## 堆排序 Heap Sort
**概念**：一种基于堆数据结构的比较排序算法<br>
**步骤**：
1. 它先将数组构造成一个大顶堆（或小顶堆）
2. 然后不断将堆顶元素（最大或最小）取出放入数组，并调整堆结构
3. 重复操作，最终得到有序数组

## 归并排序 Merge Sort
**概念**：把序列分成长度相同的两个子序列，当无法继续往下分时（也就是每个子序列中只有一个数据时），就对子序列进行归并。归并指的是把两个排好序的子序列合并成一个有序序列。该操作会一直重复执行，直到所有子序列都归并为一个整体为止<br>
**步骤**：将数组一分为二，将数组拆分到最小，再逐步归并

<img src="https://i-blog.csdnimg.cn/direct/7137788bce6b4cb3bc342ed73520342a.png#pic_center" width="300">

## 快速排序 Quick Sort
**概念**：一种基于分治思想的高效排序算法<br>
**步骤**：
1.  从数组中选择一个“基准值”（pivot）
2.  将数组分为两部分：
`[ 比基准值小的数 ] 基准值 [ 比基准值大的数 ]`
3.  对左右两侧递归 (在算法内部继续使用该算法的现象) 排序

# 数组的查找
| 查找方法       | 是否需要排序 | 时间复杂度 |
|----------------|----------------|------------------|
| 线性查找       | 否             | O(n)             |
| 二分查找       | 是             | O(log n)         |

## 线性查找 Linear Search
**概念**：一种最基础的查找算法，逐个遍历数组，依次与目标值比较<br>
**步骤**：从头到尾逐一比较：如果当前元素 == 目标值 → 返回索引
，否则继续向后查找，直到末尾

## 二分查找 Binary Search
**概念**：一种在有序数组中快速查找目标元素的算法<br>
**步骤**：二分查找通过比较数组中间的数据与目标数据的大小，可以得知目标数据是在数组的左边还是右边。因此，比较一次就可以把查找范围缩小一半。重复执行该操作就可以找到目标数据，或得出目标数据不存在的结论

# 图
## 广度优先搜索 BFS, Breadth-First Search 
**概念**：一种图遍历算法，从起始节点出发，优先访问当前节点的所有邻居，再访问下一层<br>
**实现方式**：候补顶点是用“先入先出”的方式来管理的，因此使用“队列”这个数据结构<br>
**步骤**：
1. 起点入队，标记为已访问
2. 从队列中取出节点，访问它的所有邻居
3. 将未访问的邻居入队并标记
4. 重复直到队列为空

## 深度优先搜索 DFS, Depth-First Search
**概念**：一种图的遍历算法，优先深入探索每一条路径直到不能再前进，然后回溯继续遍历其他路径<br>
**实现方式**：候补顶点是用“后入先出”的方式来管理的，因此使用“栈”这个数据结构<br>
**步骤**：
1. 从起始节点开始访问
2. 对每个未访问的相邻节点，递归执行 DFS
3. 直到所有节点都访问完毕