# 网络体系结构
**概念**：计算机网络的各层及其协议的集合

<img src="https://i-blog.csdnimg.cn/direct/8563f8e4a76b4424a60abcb6029f4a15.png#pic_center" width="700">

## OSI参考模型

<img src="https://i-blog.csdnimg.cn/direct/0f986b55bfbd4caaa0666f7e8292b93e.png#pic_center" width="700">

1. 应用层：最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP (文件传输协议) 等
2. 表示层：提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。数据压缩和加密也是表示层可提供的转换功能之一
3. 会话层：负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成
4. 传输层：建立了主机端到端的链接，TCP UDP就是在这一层。端口号既是这里的“端”。可以理解为传输层则规定了数据包的传输方式
5. 网络层：通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。可以理解为网络层规定了数据包的传输路线
6. 数据链路层：将比特组合成字节,再将字节组合成帧，使用链路层地址 (以太网使用MAC地址)来访问介质，并进行差错检测。可以理解为数据链路层就是传输路线。还增加了差错控制的功能
7. 物理层：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境

**通信特点**：对等通信。为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信

## TCP/IP模型

<img src="https://i-blog.csdnimg.cn/direct/3ff628563ce946be96847501a67cfc00.png#pic_center" width="700">

# TCP 与 UDP
1. **传输控制协议 (Transmission Control Protocol，TCP)**
    - 面向连接：指发送数据前必须在两端建立连接
    - 可靠传输，保证数据不丢、不重、不乱序
    - 仅支持单播传输：每条TCP传输连接只能有两个端点，只能进行点对点数据传输
    - 面向字节流：不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输
    - 适合对可靠性要求高的应用，如：网页、文件传输、邮件
2. **用户数据报协议 (User Datagram Protocol，UDP)**
    - 面向无连接，传输简单快速
    - 不保证可靠性，可能丢包、乱序
    - 有单播，多播，广播的功能：不只支持一对一传输，同样支持一对多，多对多，多对一的方式
    - 面向报文：发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文
    - 头部开销小，传输数据报文时很高效
    - 低延迟，适合实时性要求高的应用，如：视频通话、在线直播、游戏

## TCP 三次握手（建立连接）
1. 客户端发送 SYN 报文，此时客户端处于 SYN_SEND 状态（请求建立连接）
2. 服务器回应 SYN + ACK 报文，此时服务器进入 SYN_RECV 状态（确认并同意建立连接）
3. 客户端发送 ACK 报文，客户端和服务器进入 ESTABLISHED 状态（确认收到，连接建立成功）

目的：保证双方都能发送、接收数据，防止错误连接

## TCP 四次挥手（断开连接）
1. 客户端发送 FIN 报文，客户端进入 FIN-WAIT-1状态（客户端请求断开）
2. 服务器回应 ACK 报文，服务端就进入了 CLOSE-WAIT 状态。客户端收到服务端的确认后，进入 FIN-WAIT-2 状态，等待服务端发出的连接释放报文段。因为TCP连接是双向的，此时服务端依旧可以发送数据给客户端（收到断开请求）
3. 服务器发送 FIN 报文，服务器进入了 LAST-ACK 状态（服务端请求断开）
4. 客户端回应 ACK 报文，，进入了 TIME-WAIT 状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL（最长报文段寿命）后，客户端才进入 CLOSED 状态。（确认断开）

*注意：最后一次挥手等待一段时间再关闭的原因是保证数据完整和无差错后再断开连接

# HTTP协议
**概念**：超文本传输协议（HyperText Transfer Protocol），它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。应用层协议，基于 TCP/IP 协议<br>
**特点**：
- 无连接：限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开链接，采用这种方式可以节省传输时间
- 无状态：状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快

*注意：HTTP协议采用明文传输信息，会存在信息安全的风险

## HTTP 报文结构
- 请求报文：
    1. 请求行（包含请求方法、URL、协议版本这三个字段）
    2. 请求头（如 User-Agent、Cookie、Content-Type）
    3. 空行
    4. 请求体（通常在 POST、PUT 请求中包含）

- 响应报文：
    1. 状态行（协议版本、状态码、状态消息）
    2. 响应头（如 Content-Type、Set-Cookie）
    3. 空行
    4. 响应体（返回的资源内容）

## 常见 HTTP 头部字段
- **Content-Type**：资源类型
- **Content-Length**：内容长度
- **User-Agent**：客户端信息
- **Host**：目标主机地址
- **Cookie**：客户端发送的 Cookie
- **Set-Cookie**：服务器设置 Cookie
- **Referer**：来源页面
- **Authorization**：认证信息

## 常见的 HTTP 请求方法
| 方法   | 说明                   |
|--------|------------------------|
| GET    | 获取资源（参数在 URL 中）|
| POST   | 提交数据（参数在请求体）|
| PUT    | 更新资源               |
| DELETE | 删除资源               |

## 常见的 HTTP 状态码
| 状态码 | 含义              |
|--------|------------------|
| 200    | OK，请求成功       |
| 301    | 永久重定向         |
| 302    | 临时重定向         |
| 304    | 资源未修改（协商缓存）|
| 400    | 错误的请求         |
| 401    | 未授权（需登录）   |
| 403    | 禁止访问           |
| 404    | 资源不存在         |
| 500    | 服务器内部错误     |
| 502    | 网关错误           |
| 503    | 服务不可用         |

## HTTP/1.1、HTTP/2、HTTP/3 版本区别
| 特性          | HTTP/1.1           | HTTP/2                 | HTTP/3             |
|---------------|--------------------|------------------------|--------------------|
| 多路复用      | 不支持（队头阻塞）  | 支持（单连接多请求）     | 支持（基于 QUIC）  |
| 连接方式      | TCP                | TCP                    | QUIC（基于 UDP）   |
| 头部压缩      | 无                 | HPACK 压缩              | QPACK 压缩         |
| 性能          | 一般               | 快                      | 更快、低延迟       |

*注意：HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许多请求排队等待的情况，这种情况被称为“队头堵塞”

## HTTP 协议的接口设计风格
1. RESTful API：最常用，基于 HTTP 协议，核心是资源导向、一切皆资源。用 URL 表示资源，用 HTTP 方法操作
2. RPC（Remote Procedure Call，远程过程调用）：核心像调用本地函数一样调用远程服务，接口风格是接口名通常是“动词”，强调执行操作，常见协议有gRPC、JSON-RPC、XML-RPC，特点是高效、适合微服务内部通信，但不直观、耦合高
3. GraphQL：acebook 提出的新风格，基于 HTTP。核心是客户端自定义数据结构，按需获取数据，特点是单个接口即可访问所有资源，减少多余数据，减少请求次数，学习曲线高，适合复杂系统
4. SOAP（Simple Object Access Protocol）：早期常用，基于 XML 的协议，特点是规范严谨、功能全面、支持事务、安全性高，缺点是复杂、臃肿、学习成本高，现在主要用于金融、电信领域

# HTTPS安全通信
**概念**：超文本传输安全协议（HyperText Transfer Protocol Secure）是基于 HTTP 和 SSL/TLS 协议（安全传输层协议，是介于TCP和HTTP之间的一层安全协议）的安全通信协议<br>
**核心功能**：
- 信息加密：数据在传输过程中不可被窃听
- 身份认证：保证通信双方身份真实可信
- 数据完整性：防止数据在传输过程中被篡改
**缺点**：
- 证书申请成本高（商业证书）
- 通信速度略慢于 HTTP
- 配置与维护更复杂

**工作过程**：
1. 客户端发起 HTTPS 请求
2. 服务器返回数字证书（包含公钥）
3. 客户端验证证书合法性，客户端生成对称密钥，并用服务器公钥加密后发送给服务器
4. 服务器用私钥解密获取对称密钥
5. 双方使用对称密钥进行加密通信

## HTTPS 与 HTTP 的区别
- HTTP 数据明文传输，容易被窃听、篡改，而 HTTPS 对数据进行加密，防止窃听和篡改
- HTTPS 需要申请数字证书，增加身份认证机制
- HTTPS 通信过程更复杂，速度略低于 HTTP，但安全性更高
- 使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS的协议端口是443

## SSL/TLS 功能实现的基本算法
- 对称加密：加密和解密用同一个密钥，速度快但密钥分发困难
- 非对称加密：使用公钥加密、私钥解密，安全但速度慢
- 散列函数hash

## 数字证书
首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改了

# 网络请求
## DNS 协议
**概念**：是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串<br>
**域名解析流程**：
1. 浏览器缓存、操作系统缓存、路由器缓存中查找域名对应 IP
2. 如果缓存中没有，向本地 DNS 服务器发送请求
3. 本地 DNS 服务器递归查询 根域名服务器、顶级域名服务器、权威域名服务器
4. 获取目标 IP 地址后返回，并保存到缓存中，完成域名解析

## CDN 加速原理
- 内容分发网络（CDN）在全球布置多个缓存节点
- 用户访问资源时，会自动就近访问最近的 CDN 节点，减少访问延迟，加快加载速度
- 主要用于加速静态资源（如图片、CSS、JS）

## WebSocket
**概念**：是HTML5提供的一种浏览器与服务器进行**全双工通讯**的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建**持久性**的连接，并进行双向数据传输。WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息

**常见应用场景**：实时聊天、即时通讯

```js
const ws = new WebSocket("ws://example.com/socket");

// 连接建立
ws.onopen = () => {
  console.log("连接已建立");
};

// 接收消息
ws.onmessage = (event) => {
  console.log("接收到消息:", event.data);
};

// 连接关闭
ws.onclose = () => {
  console.log("连接已关闭");
};

// 发生错误
ws.onerror = (error) => {
  console.error("发生错误:", error);
};

// 发送消息
ws.send("Hello, server!");
```

### WebSocket 与 HTTP 的关系
| 特性           | WebSocket                          | HTTP                              |
|----------------|-----------------------------------|----------------------------------|
| 连接方式       | 一次握手后，建立持久连接           | 每次请求都需建立和关闭连接       |
| 通信方向       | 双向通信，客户端和服务器均可主动发送 | 单向通信，客户端主动请求，服务器响应 |
| 数据传输       | 长连接，实时性强                   | 短连接，实时性差                 |
| 传输协议       | 基于 TCP，应用层协议               | 基于 TCP，应用层协议             |

# 浏览器相关网络机制
## 浏览器渲染
**渲染流程**：
1. **解析 HTML → 构建 DOM 树** ：浏览器自上而下解析 HTML，生成结构化的 DOM（文档对象模型）
2. **解析 CSS → 构建 CSSOM 树** ：浏览器解析所有 CSS（包括 `<style>`、外链样式、内联样式），构建 CSSOM（CSS 对象模型）树
3. **DOM + CSSOM 合并 → 构建渲染树（Render Tree）**
4. **布局（Layout）** ：计算每个渲染对象的几何位置（宽、高、坐标等），即确定“放在哪”
5. **绘制（Painting）** ：将渲染树节点绘制成实际像素，提交给浏览器的绘图引擎
6. **合成（Compositing）** ：各层（图层）内容被组合成最终页面，并由 GPU（图形处理器）渲染到屏幕上

## 重排和重绘
**重排/回流（Reflow）**：浏览器重新计算元素的几何信息（如尺寸、位置、结构），导致页面布局重新构建，比如改变浏览器窗口大小、改变元素内容、添加或删除可见的DOM元素等会触发，性能开销大<br>
**重绘（Repaint）**：浏览器更新元素的可视样式（如颜色、背景），但不影响布局，比如修改 color、background、border-radius、visibility、box-shadow 时会触发，性能开销较小

*注意：重排必然引起重绘，但重绘不一定触发重排

## 浏览器缓存机制
1. 强缓存（不发请求，直接用本地缓存）
    - 常用响应头：
    - Cache-Control（推荐，优先级高）
    - Expires（旧版本，基于时间戳）
    - 特点：缓存未过期时，浏览器不发请求，直接使用缓存

2. 协商缓存（会发请求，但可节省资源）
    - 常用响应头：
    - ETag + If-None-Match
    - Last-Modified + If-Modified-Since
    - 特点：浏览器发请求，服务器根据缓存标识判断资源是否修改，未修改返回 304 Not Modified，继续使用缓存；若资源已更新，则返回新资源

## 浏览器存储
**概念**：包含 Local Storage、Session Storage、IndexedDB、Web SQL、Cookies<br>
**使用场景**：
- 保存应用状态，比如保持用户偏好（用户特定的设置，例如亮模式或暗模式、字体大小等）
- 创建离线工作的渐进式 Web 应用，除了初始下载和更新之外没有服务器端要求
- 缓存静态应用资源，如 HTML、CSS、JS 和图像等
- 保存上一个浏览会话中的数据，例如存储上一个会话中的购物车内容，待办事项列表中的项目，记住用户是否以前登录过等

**优势**：将这些信息保存在客户端可以减少额外且不必要的服务器调用，并帮助提供离线支持

### Web Storage
**概念**：包含 Local Storage、Session Storage

### Cookie
**概念**：Cookie 是浏览器保存的一小段键值对数据，用于身份验证、会话管理和个性化设置，每次请求时会自动发送给服务器，可由服务器或浏览器设置，并支持设置过期时间。Cookie 是前端与后端通信中唯一会自动随请求发送的存储方式，但大小和数量都有限制（通常每个域名最多 4KB，约 20 个）<br>
**Cookie 操作**：
```js
// 设置 Cookie（max-age 指定 Cookie 的有效时间，单位秒，这里表示1小时后过期）
document.cookie = "username=Tom; max-age=3600; path=/"; 

// 访问所有 Cookie（返回一个字符串）
console.log(document.cookie); // "username=Tom"

// 修改 Cookie
document.cookie = "username=Jerry; max-age=3600; path=/"; 

// 删除 Cookie（通过expires设置过期时间为过去的时间）
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/"; 
```
**Cookie 工具库**：
1. js-cookie：`npm i js-cookie`
    ```js
    import Cookies from 'js-cookie';

    // 设置（1 小时后过期，1 小时 = 1天 / 24）
    Cookies.set('username', 'Tom', { expires: 1 / 24 }); 

    // 读取
    const name = Cookies.get('username');

    // 修改
    Cookies.set('username', 'Jerry');

    // 删除
    Cookies.remove('username');
    ```
2. react-cookie：`npm i react-cookie`
    ```js
    import { useCookies } from 'react-cookie';

    const [cookies, setCookie, removeCookie] = useCookies(['username']);

    // 设置
    setCookie('username', 'Tom', { path: '/', maxAge: 3600 });

    // 读取
    console.log(cookies.username);

    // 删除
    removeCookie('username');
    ```

*注意不能跨浏览器读取cookie

### 存储区别
| 特性           | Cookie                  | LocalStorage       | SessionStorage     |
|----------------|-------------------------|--------------------|--------------------|
| 存储大小       | ~4KB                    | 约5MB              | 约5MB              |
| 有效期         | 可设置过期时间          | 长期存储，除非手动删除 | 会话结束即清除     |
| 是否随请求发送 | 是                      | 否                 | 否                 |
| 应用场景       | 用户认证、会话管理      | 本地持久化存储     | 临时数据存储       |

# Web 安全基础

## 常见 Web 安全问题
1. XSS（跨站脚本攻击）
    - 原理：攻击者通过注入恶意脚本，窃取用户信息或篡改页面
    - 防御措施：
        - 输入内容严格校验、转义
        - 使用 CSP（内容安全策略）：它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行
2. CSRF（跨站请求伪造）
    - 原理：攻击者诱导用户浏览恶意网站，自动向目标网站发送请求，利用用户已登录的身份执行操作。本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充
    - 防御措施：
        - 校验 Referer / Origin
        - 添加 CSRF Token 验证
        - 设置 SameSite Cookie 属性

## 同源策略（Same-Origin Policy）
- 浏览器核心安全机制，限制不同源之间访问接口和 DOM
- 同源判定标准：
  - 协议、域名、端口必须全部相同

## Token
**概念**：Token 是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登录后，服务器会生成一个 Token 并返回给客户端，客户端后续访问时，只需带上这个 Token 即可完成身份认证

### JWT 基础原理
**概念**：最常见的 Token 生成方式是使用 JWT（Json Web Token），基于JSON格式的身份验证令牌，用于在客户端和服务器之间安全地传递用户身份信息<br>
**特点**：
- 无需服务器存储会话，前后端分离
- 结构包含：Header（头部，说明使用的算法和类型）、Payload（负载，包含用户信息和自定义数据）、Signature（签名，防止篡改，服务器用密钥签名前两部分）
- 可用于用户认证、接口权限控制


